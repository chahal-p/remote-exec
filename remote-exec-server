#!/usr/bin/env python3

import typing
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import dsa, ec, rsa, ed25519, ed448, padding
from cryptography.hazmat.primitives.asymmetric.types import PublicKeyTypes
from datetime import datetime, timedelta, timezone
from http import HTTPStatus
from queue import Queue, Empty as EmptyQueueError
from websockets.sync.server import serve

import argparse
import base64
import logging
import os
import re
import subprocess
import threading
import time
import traceback
import websockets

FLAGS=None

DEFAULT_PORT = 5567

AUTHORIZED_PUBLIC_KEYS: list[PublicKeyTypes] = ()

SUPPORTED_KEY_TYPES = [
  dsa.DSAPublicKey,
  rsa.RSAPublicKey,
  ec.EllipticCurvePublicKey,
  ed25519.Ed25519PublicKey,
  ed448.Ed448PublicKey,
]

MAX_MESSAGE_SIZE = 8192

class OutputType:
  STDOUT = 1
  STDERR = 2
  CODE   = 3


class CommandHandler():

  def exec(self, cmd: list, cwd:str, stdin, cancelled: threading.Event):
    self.validate_cmd(' '.join(cmd))
    process = None
    try:
      process = subprocess.Popen(cmd, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=stdin)
    except Exception as e:
      cancelled.set()
      traceback.print_exception(e)
      yield format_stderr('{}\n'.format(str(e))), 1
    if not process:
      return
    on_cancellation(cancelled, self.process_killer(process))
    for l in output_reader(process.stdout, process.stderr, cancelled):
      yield l, None
    for _ in range(10):
      try:
        process.wait(1)
        break
      except subprocess.TimeoutExpired:
        pass
    yield None, process.returncode

  def validate_cmd(self, cmd):
    if not FLAGS.allowed_commands:
      raise NotAllowedError(f'Command not Allowed: {cmd}')
    for rep in FLAGS.allowed_commands:
      if rep == '':
        continue
      reg = re.compile(rep)
      if reg.match(cmd):
        return
    raise NotAllowedError(f'Command not Allowed: {cmd}')
  
  def process_killer(self, process):
    def wrap():
      if process.returncode is None:
        process.kill()
        print(f'Process {process.pid} killed!')
    return wrap

def stream_stdin(ws: websockets.ServerConnection, dest, cancelled: threading.Event):
  def target():
    try:
      while not cancelled.is_set():
        data = ws.recv()
        if data:
          os.write(dest, data)
        else:
          break
    except websockets.exceptions.ConnectionClosed:
      cancelled.set()
    finally:
      os.close(dest)
  threading.Thread(target=target, daemon=True).start()

def output_reader(stdout: typing.IO[bytes], stderr, cancelled: threading.Event):
  queue = Queue()
  done_stdout = threading.Event()
  done_stderr = threading.Event()
  t1 = threading.Thread(target=read_from_pipe, daemon=True, args=[stdout, queue, OutputType.STDOUT, done_stdout, cancelled])
  t2 = threading.Thread(target=read_from_pipe, daemon=True, args=[stderr, queue, OutputType.STDERR, done_stderr, cancelled])
  t1.start()
  t2.start()
  while not queue.empty() or not done_stdout.is_set() or not done_stderr.is_set():
    try:
      yield queue.get(timeout=0.1)
    except EmptyQueueError:
      pass

def format_output(type: OutputType, data: bytes|str|int) -> bytes:
  if isinstance(data, bytes):
    return int.to_bytes(type) + data
  elif isinstance(data, str):
    return int.to_bytes(type) + str.encode(data)
  if isinstance(data, int):
    return int.to_bytes(type) + int.to_bytes(data)
  else:
    raise TypeError('Unsupported type')

def format_stderr(data: bytes|str|int) -> bytes:
  return format_output(OutputType.STDERR, data)

def format_returncode(code: int) -> bytes:
  return format_output(OutputType.CODE, code)

def read_from_pipe(pipe: typing.IO[bytes], queue: Queue, type: OutputType, done: threading.Event, cancelled: threading.Event):
  with pipe:
    while not cancelled.is_set():
      data = os.read(pipe.fileno(), MAX_MESSAGE_SIZE)
      if not data:
        break
      queue.put(format_output(type, data))
  done.set()

def hexstr(data: str|bytes|int):
  if isinstance(data, bytes):
    return bytes.hex(data)
  return bytes.hex(str(data).encode())

def on_cancellation(cancelled: threading.Event, callback, *args, **kwargs):
  def checker():
    while True:
      if cancelled.is_set():
        callback(*args, **kwargs)
        return
      time.sleep(0.5)
  threading.Thread(target=checker, daemon=True).start()

def validate_token(token: str):
  if not token:
    return False
  now = datetime.now(timezone.utc)
  mintime = now - timedelta(seconds=3)
  maxtime = now + timedelta(seconds=1)
  parts = token.split('.')
  if len(parts) != 2:
    return False
  data_bytes, sig_bytes = base64.b64decode(parts[0]), base64.b64decode(parts[1])
  if not verify_sig(sig_bytes, data_bytes):
    return False
  token_timestamp = datetime.fromtimestamp(float(data_bytes.decode()), timezone.utc)
  if token_timestamp > mintime and token_timestamp < maxtime:
    return True
  return False

def verify_sig(sig_bytes, data_bytes):
  for public_key in AUTHORIZED_PUBLIC_KEYS:
    try:
      if isinstance(public_key, ec.EllipticCurvePublicKey):
        public_key.verify(signature=sig_bytes, data=data_bytes, signature_algorithm=ec.ECDSA(hashes.SHA256()))
      elif isinstance(public_key, rsa.RSAPublicKey):
        p = padding.PSS(
          mgf=padding.MGF1(hashes.SHA256()),
          salt_length=padding.PSS.MAX_LENGTH
        )
        public_key.verify(signature=sig_bytes, data=data_bytes, padding=p, algorithm=hashes.SHA256())
      else:
        public_key.verify(signature=sig_bytes, data=data_bytes, algorithm=hashes.SHA256())
      return True
    except Exception as e:
      pass
  return False

def init_authorized_keys():
  global AUTHORIZED_PUBLIC_KEYS, SUPPORTED_KEY_TYPES
  public_keys = []
  for file in FLAGS.authorized_key_file:
    with open(file, 'rb') as f:
      content = f.read()
    loaders = [
      serialization.load_pem_public_key,
      serialization.load_der_public_key,
      serialization.load_ssh_public_key
    ]
    for loader in loaders:
      public_key = None
      try:
        public_key = loader(
          data = content,
          backend=default_backend()
        )
      except Exception:
        pass
      if public_key:
        break
    supported = False
    for key_type_cls in SUPPORTED_KEY_TYPES:
      if isinstance(public_key, key_type_cls):
        supported = True
        break
    if not supported:
      raise KeyTypeNotSupported('Key type not supported')
    public_keys.append(public_key)
  AUTHORIZED_PUBLIC_KEYS = tuple(public_keys)

def cancel_on_connection_closed(ws: websockets.ServerConnection, cancelled: threading.Event):
  def pinger():
    while not cancelled.is_set():
      try:
        ws.ping()
        time.sleep(3)
      except websockets.ConnectionClosed:
        cancelled.set()
        return
  threading.Thread(target=pinger, daemon=True).start()

def websocket_handler(ws: websockets.ServerConnection):
  cancelled = threading.Event()
  cancel_on_connection_closed(ws, cancelled)
  cwd = ws.request.headers.get('CWD', None)
  encoded_cmd: bytes = ws.recv()
  cmd = []
  for arg in encoded_cmd.decode().split(':'):
    cmd.append(base64.b64decode(arg).decode())
  stdin_read_fd, stdin_write_fd = os.pipe()
  try:
    stream_stdin(ws, stdin_write_fd, cancelled)
    cmd_handler = CommandHandler()
    for line, code in cmd_handler.exec(cmd, cwd, stdin_read_fd, cancelled):
      if line is not None:
        ws.send(line)
      if code is not None:
        ws.send(format_returncode(code))
  except NotAllowedError as e:
    cancelled.set()
    traceback.print_exception(e)
    ws.send(format_stderr('{}\n'.format(str(e))))
    ws.send(format_returncode(1))
  except Exception as e:
    cancelled.set()
    traceback.print_exception(e)
    ws.send(format_stderr('Internal Server Error\n'))
    ws.send(format_returncode(1))
  finally:
    os.close(stdin_read_fd)
    cancelled.set()
    ws.close()
  

def process_http_request(ws: websockets.ServerConnection, request: websockets.Request):
  if not FLAGS.disable_auth:
    resp_headers = websockets.Headers()
    authtoken = request.headers.get('Authorization', None)
    if authtoken:
      if not validate_token(authtoken):
        return websockets.Response(HTTPStatus.UNAUTHORIZED, 'UNAUTHORIZED', resp_headers, format_stderr('Invalid auth token\n'))
    else:
      return websockets.Response(HTTPStatus.UNAUTHORIZED, 'UNAUTHORIZED', resp_headers, format_stderr('Auth token not provided\n'))
    remote_addr, _ = ws.remote_address
    if remote_addr != '127.0.0.1':
      return websockets.Response(HTTPStatus.FORBIDDEN, 'FORBIDDEN', resp_headers, format_stderr('Not allowed\n'))

class NotAllowedError(Exception):
  pass

class KeyTypeNotSupported(Exception):
  pass

class NotAbleToParseBody(Exception):
  pass


if __name__ == "__main__":
  parser = argparse.ArgumentParser(description="Exec server starts a http server to recieve commands and execute those.")
  parser.add_argument('-p', '--port', metavar='', type=int, help="Port used by server to listen", default=DEFAULT_PORT)
  parser.add_argument('-a', '--allowed-commands', action='append', metavar='', type=str, help="Regex pattern for allowed commands, to allow all commands specify '.*'", default=[])
  parser.add_argument('-c', '--cwd', metavar='', type=str, help="Set working directory", default=None)
  parser.add_argument('--authorized-key-file', action='append', metavar='', type=str, help="File path of authorized public key, multiple can be specified", default=[])
  parser.add_argument('--disable-auth', action='store_true', help="Disable authentication")
  parser.add_argument('--debug', action='store_true', help="Enable debug logging")
  FLAGS = parser.parse_args()
  if not FLAGS.disable_auth and len(FLAGS.authorized_key_file) == 0:
    raise ValueError('--authorized-key-file is a required arg if --disable-auth is not specified.')
  init_authorized_keys()
  if FLAGS.cwd:
    os.chdir(FLAGS.cwd)
  if FLAGS.debug:
    logging.basicConfig(
        format="%(asctime)s %(message)s",
        level=logging.DEBUG,
    )
  with serve(handler=websocket_handler, process_request=process_http_request, host="localhost", port=FLAGS.port) as server:
    print(f'Listening at {FLAGS.port}')
    server.serve_forever()
