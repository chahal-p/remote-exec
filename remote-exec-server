#!/usr/bin/env python3

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import dsa, ec, rsa, ed25519, ed448, padding
from cryptography.hazmat.primitives.asymmetric.types import PUBLIC_KEY_TYPES
from datetime import datetime, timedelta, timezone
from queue import Queue, Empty as EmptyQueueError

import argparse
import base64
import http.server
import os
import re
import socketserver
import subprocess
import traceback
import threading
import time

FLAGS=None

DEFAULT_PORT = 5567

AUTHORIZED_PUBLIC_KEYS: list[PUBLIC_KEY_TYPES] = ()

SUPPORTED_KEY_TYPES = [
  dsa.DSAPublicKey,
  rsa.RSAPublicKey,
  ec.EllipticCurvePublicKey,
  ed25519.Ed25519PublicKey,
  ed448.Ed448PublicKey,
]

class HTTPRequestHandler(http.server.BaseHTTPRequestHandler):
  def run(self, cmd: list, cwd:str, cancelled: threading.Event):
    self.validate_cmd(' '.join(cmd))
    try:
      process = subprocess.Popen(cmd, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except Exception as e:
      cancelled.set()
      traceback.print_exception(e)
      yield stderr_line('{}\n'.format(str(e))), 1
    on_cancellation(cancelled, process.kill)
    for l in output_reader(process.stdout, process.stderr, cancelled):
      yield l, None
    for _ in range(10):
      try:
        process.wait(1)
        break
      except subprocess.TimeoutExpired:
        pass
    yield None, process.returncode

  def do_POST(self):
    cancelled = threading.Event()
    try:
      if not FLAGS.disable_auth:
        authtoken = self.headers.get('Authorization', None)
        if authtoken:
          if not validateAuth(authtoken):
            raise NotAllowedError('Invalid auth token')
        else:
          raise NotAllowedError('Auth token not provided')
      self.exec(cancelled)
      cancelled.set()
    except NotAllowedError as e:
      cancelled.set()
      traceback.print_exception(e)
      self.send_response(200)
      self.end_headers()
      self.wfile.write(stderr_line('{}\n'.format(str(e))))
      self.wfile.write(returncode_line(1))
    except Exception as e:
      cancelled.set()
      traceback.print_exception(e)
      self.send_response(500)
      self.end_headers()
      self.wfile.write(stderr_line('Internal Server Error\n'))
      self.wfile.write(returncode_line(1))

  def validate_cmd(self, cmd):
    if not FLAGS.allowed_commands:
      raise NotAllowedError(f'Command not Allowed: {cmd}')
    for rep in FLAGS.allowed_commands:
      if rep == '':
        continue
      reg = re.compile(rep)
      if reg.match(cmd):
        return
    raise NotAllowedError(f'Command not Allowed: {cmd}')

  def exec(self, cancelled: threading.Event):
    try:
      if 'Content-Length' not in self.headers:
        raise ValueError("Content-Length header not provided")
      clientaddr, _ = self.client_address
      if clientaddr != '127.0.0.1':
        raise NotAllowedError('exec server can only recieve request from 127.0.0.1')
      content_length = int(self.headers['Content-Length'])
      post_data_hex = self.rfile.read(content_length).decode('utf-8')
      cmd = []
      for arg in post_data_hex.split(':'):
        cmd.append(bytes.fromhex(arg).decode('utf-8'))
      self.send_response(200)
      self.send_header('Content-Type', 'application/octet-stream')
      self.end_headers()
      self.cancel_on_connection_closed(cancelled)
      cwd = self.headers.get('CWD', None)
      for line, code in self.run(cmd, cwd, cancelled):
        if line is not None:
          self.wfile.write(line)
        if code is not None:
          self.wfile.write(returncode_line(code))
    except ValueError as e:
      cancelled.set()
      traceback.print_exception(e)
      self.send_response(400)
      self.end_headers()
      self.wfile.write(stderr_line(str(e)))
      self.wfile.write(returncode_line(2))

  def cancel_on_connection_closed(self, cancelled: threading.Event):
    def checker():
      while True:
        if cancelled.is_set():
          break
        try:
          self.wfile.write('PING\n'.encode('utf-8'))
        except Exception as e:
          traceback.print_exception(e)
          cancelled.set()
          break
        time.sleep(5)
    threading.Thread(target=checker).start()


class ThreadedHTTPServer(socketserver.ThreadingMixIn, http.server.HTTPServer):
  pass


class NotAllowedError(Exception):
  pass

class KeyTypeNotSupported(Exception):
  pass


def hexstr(data: str|bytes|int):
  if isinstance(data, bytes):
    return bytes.hex(data)
  return bytes.hex(str(data).encode())

def output_line(type: str, line: str|bytes|int) -> bytes:
  return '{}:{}\n'.format(type, hexstr(line)).encode('utf-8')

def stdout_line(line: str|bytes) -> bytes:
  return output_line('STDOUT', line)

def stderr_line(line: str|bytes) -> bytes:
  return output_line('STDERR', line)

def returncode_line(code: int) -> bytes:
  return output_line('CODE', code)

def on_cancellation(cancelled: threading.Event, callback, *args, **kwargs):
  def checker():
    while True:
      if cancelled.is_set():
        callback(*args, **kwargs)
        break
      time.sleep(0.1)
  threading.Thread(target=checker).start()

def read_from_pipe(pipe, queue: Queue, type: str, done: threading.Event, cancelled: threading.Event):
  with pipe:
    for line in iter(pipe.readline, b''):
      if cancelled.is_set():
        break
      queue.put(output_line(type, line))
  done.set()

def output_reader(stdout, stderr, cancelled: threading.Event):
  queue = Queue()
  done_stdout = threading.Event()
  done_stderr = threading.Event()
  t1 = threading.Thread(target=read_from_pipe, args=[stdout, queue, 'STDOUT', done_stdout, cancelled])
  t2 = threading.Thread(target=read_from_pipe, args=[stderr, queue, 'STDERR', done_stderr, cancelled])
  t1.start()
  t2.start()
  while not queue.empty() or not done_stdout.is_set() or not done_stderr.is_set():
    try:
      yield queue.get(timeout=0.1)
    except EmptyQueueError:
      pass

def validateAuth(token: str):
  if not token:
    return False
  now = datetime.now(timezone.utc)
  mintime = now - timedelta(seconds=3)
  maxtime = now + timedelta(seconds=1)
  parts = token.split('.')
  if len(parts) != 2:
    return False
  data_bytes, sig_bytes = base64.b64decode(parts[0]), base64.b64decode(parts[1])
  if not verify_sig(sig_bytes, data_bytes):
    return False
  token_timestamp = datetime.fromtimestamp(float(data_bytes.decode()), timezone.utc)
  if token_timestamp > mintime and token_timestamp < maxtime:
    return True
  return False

def verify_sig(sig_bytes, data_bytes):
  for public_key in AUTHORIZED_PUBLIC_KEYS:
    try:
      if isinstance(public_key, ec.EllipticCurvePublicKey):
        public_key.verify(signature=sig_bytes, data=data_bytes, signature_algorithm=ec.ECDSA(hashes.SHA256()))
      elif isinstance(public_key, rsa.RSAPublicKey):
        p = padding.PSS(
          mgf=padding.MGF1(hashes.SHA256()),
          salt_length=padding.PSS.MAX_LENGTH
        )
        public_key.verify(signature=sig_bytes, data=data_bytes, padding=p, algorithm=hashes.SHA256())
      else:
        public_key.verify(signature=sig_bytes, data=data_bytes, algorithm=hashes.SHA256())
      return True
    except Exception as e:
      pass
  return False

def init_authorized_keys():
  global AUTHORIZED_PUBLIC_KEYS, SUPPORTED_KEY_TYPES
  public_keys = []
  for file in FLAGS.authorized_key_file:
    with open(file, 'rb') as f:
      content = f.read()
    loaders = [
      serialization.load_pem_public_key,
      serialization.load_der_public_key,
      serialization.load_ssh_public_key
    ]
    for loader in loaders:
      public_key = None
      try:
        public_key = loader(
          data = content,
          backend=default_backend()
        )
      except Exception:
        pass
      if public_key:
        break
    supported = False
    for key_type_cls in SUPPORTED_KEY_TYPES:
      if isinstance(public_key, key_type_cls):
        supported = True
        break
    if not supported:
      raise KeyTypeNotSupported('Key type not supported')
    public_keys.append(public_key)
  AUTHORIZED_PUBLIC_KEYS = tuple(public_keys)

if __name__ == "__main__":
  parser = argparse.ArgumentParser(description="Exec server starts a http server to recieve commands and execute those.")
  parser.add_argument('-p', '--port', metavar='', type=int, help="Port used by server to listen", default=DEFAULT_PORT)
  parser.add_argument('-a', '--allowed-commands', action='append', metavar='', type=str, help="Regex pattern for allowed commands, to allow all commands specify '.*'", default=[])
  parser.add_argument('-c', '--cwd', metavar='', type=str, help="Set working directory", default=None)
  parser.add_argument('--authorized-key-file', action='append', metavar='', type=str, help="File path of authorized public key, multiple can be specified", default=[])
  parser.add_argument('--disable-auth', action='store_true', help="Disable authentication")
  FLAGS = parser.parse_args()
  if not FLAGS.disable_auth and len(FLAGS.authorized_key_file) == 0:
    raise ValueError('--authorized-key-file is a required arg if --disable-auth is not specified.')
  init_authorized_keys()
  if FLAGS.cwd:
    os.chdir(FLAGS.cwd)
  with ThreadedHTTPServer(("", FLAGS.port), HTTPRequestHandler) as server:
    print(f"Serving at port {FLAGS.port}")
    print("Server is running... Press Ctrl+C to stop.")
    server.serve_forever()
