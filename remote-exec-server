#!/usr/bin/env python3

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import dsa, ec, rsa, ed25519, ed448, padding
from cryptography.hazmat.primitives.asymmetric.types import PublicKeyTypes
from datetime import datetime, timedelta, timezone
from http import HTTPStatus
from queue import Queue, Empty as EmptyQueueError
from websockets.sync.server import serve

import argparse
import base64
import http.server
import os
import re
import subprocess
import traceback
import threading
import time
import websockets

FLAGS=None

DEFAULT_PORT = 5567

AUTHORIZED_PUBLIC_KEYS: list[PublicKeyTypes] = ()

SUPPORTED_KEY_TYPES = [
  dsa.DSAPublicKey,
  rsa.RSAPublicKey,
  ec.EllipticCurvePublicKey,
  ed25519.Ed25519PublicKey,
  ed448.Ed448PublicKey,
]

class CommandHandler():

  def exec(self, cmd: list, cwd:str, stdin, cancelled: threading.Event):
    self.validate_cmd(' '.join(cmd))
    process = None
    try:
      process = subprocess.Popen(cmd, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=stdin)
    except Exception as e:
      cancelled.set()
      traceback.print_exception(e)
      yield stderr_line('{}\n'.format(str(e))), 1
    if not process:
      return
    on_cancellation(cancelled, self.process_killer(process))
    for l in output_reader(process.stdout, process.stderr, cancelled):
      yield l, None
    for _ in range(10):
      try:
        process.wait(1)
        break
      except subprocess.TimeoutExpired:
        pass
    yield None, process.returncode

  def validate_cmd(self, cmd):
    if not FLAGS.allowed_commands:
      raise NotAllowedError(f'Command not Allowed: {cmd}')
    for rep in FLAGS.allowed_commands:
      if rep == '':
        continue
      reg = re.compile(rep)
      if reg.match(cmd):
        return
    raise NotAllowedError(f'Command not Allowed: {cmd}')
  
  def process_killer(self, process):
    def wrap():
      if process.returncode is None:
        process.kill()
        print(f'Process {process.pid} killed!')
    return wrap

def stream_stdin(ws: websockets.ServerConnection, dest, cancelled: threading.Event):
  def target():
    try:
      while not cancelled.is_set():
        data = extract_data(ws.recv())
        if data is None:
          break
        os.write(dest, data)
    except websockets.exceptions.ConnectionClosed:
      cancelled.set()
    finally:
      os.close(dest)
  threading.Thread(target=target, daemon=True).start()

def extract_data(bd: bytes):
  idx = bd.find(b'\r\n')
  if idx == -1:
    raise NotAbleToParseBody()
  size = int(bd[:idx], base=16)
  if size == 0:
    return None
  data = bd[idx+2:]
  if len(data) != size:
    raise NotAbleToParseBody()
  return data

def output_reader(stdout, stderr, cancelled: threading.Event):
  queue = Queue()
  done_stdout = threading.Event()
  done_stderr = threading.Event()
  t1 = threading.Thread(target=read_from_pipe, args=[stdout, queue, 'STDOUT', done_stdout, cancelled])
  t2 = threading.Thread(target=read_from_pipe, args=[stderr, queue, 'STDERR', done_stderr, cancelled])
  t1.start()
  t2.start()
  while not queue.empty() or not done_stdout.is_set() or not done_stderr.is_set():
    try:
      yield queue.get(timeout=0.1)
    except EmptyQueueError:
      pass

def output_line(type: str, line: str|bytes|int) -> bytes:
  return '{}:{}'.format(type, hexstr(line)).encode('utf-8')

def stdout_line(line: str|bytes) -> bytes:
  return output_line('STDOUT', line)

def stderr_line(line: str|bytes) -> bytes:
  return output_line('STDERR', line)

def returncode_line(code: int) -> bytes:
  return output_line('CODE', code)

def read_from_pipe(pipe, queue: Queue, type: str, done: threading.Event, cancelled: threading.Event):
  with pipe:
    for line in iter(pipe.readline, b''):
      if cancelled.is_set():
        break
      queue.put(output_line(type, line))
  done.set()

def hexstr(data: str|bytes|int):
  if isinstance(data, bytes):
    return bytes.hex(data)
  return bytes.hex(str(data).encode())

def on_cancellation(cancelled: threading.Event, callback, *args, **kwargs):
  def checker():
    while True:
      if cancelled.is_set():
        callback(*args, **kwargs)
        return
      time.sleep(0.5)
  threading.Thread(target=checker).start()

def validate_token(token: str):
  if not token:
    return False
  now = datetime.now(timezone.utc)
  mintime = now - timedelta(seconds=3)
  maxtime = now + timedelta(seconds=1)
  parts = token.split('.')
  if len(parts) != 2:
    return False
  data_bytes, sig_bytes = base64.b64decode(parts[0]), base64.b64decode(parts[1])
  if not verify_sig(sig_bytes, data_bytes):
    return False
  token_timestamp = datetime.fromtimestamp(float(data_bytes.decode()), timezone.utc)
  if token_timestamp > mintime and token_timestamp < maxtime:
    return True
  return False

def verify_sig(sig_bytes, data_bytes):
  for public_key in AUTHORIZED_PUBLIC_KEYS:
    try:
      if isinstance(public_key, ec.EllipticCurvePublicKey):
        public_key.verify(signature=sig_bytes, data=data_bytes, signature_algorithm=ec.ECDSA(hashes.SHA256()))
      elif isinstance(public_key, rsa.RSAPublicKey):
        p = padding.PSS(
          mgf=padding.MGF1(hashes.SHA256()),
          salt_length=padding.PSS.MAX_LENGTH
        )
        public_key.verify(signature=sig_bytes, data=data_bytes, padding=p, algorithm=hashes.SHA256())
      else:
        public_key.verify(signature=sig_bytes, data=data_bytes, algorithm=hashes.SHA256())
      return True
    except Exception as e:
      pass
  return False

def init_authorized_keys():
  global AUTHORIZED_PUBLIC_KEYS, SUPPORTED_KEY_TYPES
  public_keys = []
  for file in FLAGS.authorized_key_file:
    with open(file, 'rb') as f:
      content = f.read()
    loaders = [
      serialization.load_pem_public_key,
      serialization.load_der_public_key,
      serialization.load_ssh_public_key
    ]
    for loader in loaders:
      public_key = None
      try:
        public_key = loader(
          data = content,
          backend=default_backend()
        )
      except Exception:
        pass
      if public_key:
        break
    supported = False
    for key_type_cls in SUPPORTED_KEY_TYPES:
      if isinstance(public_key, key_type_cls):
        supported = True
        break
    if not supported:
      raise KeyTypeNotSupported('Key type not supported')
    public_keys.append(public_key)
  AUTHORIZED_PUBLIC_KEYS = tuple(public_keys)

def cancel_on_connection_closed(ws: websockets.ServerConnection, cancelled: threading.Event):
  def pinger():
    while not cancelled.is_set():
      try:
        ws.ping()
        time.sleep(3)
      except websockets.ConnectionClosed:
        cancelled.set()
        return
  threading.Thread(target=pinger, daemon=True).start()

def websocket_handler(ws: websockets.ServerConnection):
  cancelled = threading.Event()
  cancel_on_connection_closed(ws, cancelled)
  cwd = ws.request.headers.get('CWD', None)
  hex_cmd = ws.recv()
  cmd = []
  for arg in hex_cmd.decode().split(':'):
    cmd.append(bytes.fromhex(arg).decode('utf-8'))
  stdin_read_fd, stdin_write_fd = os.pipe()
  try:
    stream_stdin(ws, stdin_write_fd, cancelled)
    cmd_handler = CommandHandler()
    for line, code in cmd_handler.exec(cmd, cwd, stdin_read_fd, cancelled):
      if line is not None:
        ws.send(line)
      if code is not None:
        ws.send(returncode_line(code))
  except NotAllowedError as e:
    cancelled.set()
    traceback.print_exception(e)
    ws.send(stderr_line('{}\n'.format(str(e))))
    ws.send(returncode_line(1))
  except Exception as e:
    cancelled.set()
    traceback.print_exception(e)
    ws.send(stderr_line('Internal Server Error\n'))
    ws.send(returncode_line(1))
  finally:
    os.close(stdin_read_fd)
    cancelled.set()
    ws.close()
  

def process_http_request(ws: websockets.ServerConnection, request: websockets.Request):
  if not FLAGS.disable_auth:
    headers = websockets.Headers()
    authtoken = request.headers.get('Authorization', None)
    if authtoken:
      if not validate_token(authtoken):
        return websockets.Response(HTTPStatus.UNAUTHORIZED, 'UNAUTHORIZED', headers, stderr_line('Invalid auth token'))
    else:
      return websockets.Response(HTTPStatus.UNAUTHORIZED, 'UNAUTHORIZED', headers, stderr_line('Auth token not provided'))

class NotAllowedError(Exception):
  pass

class KeyTypeNotSupported(Exception):
  pass

class NotAbleToParseBody(Exception):
  pass


if __name__ == "__main__":
  parser = argparse.ArgumentParser(description="Exec server starts a http server to recieve commands and execute those.")
  parser.add_argument('-p', '--port', metavar='', type=int, help="Port used by server to listen", default=DEFAULT_PORT)
  parser.add_argument('-a', '--allowed-commands', action='append', metavar='', type=str, help="Regex pattern for allowed commands, to allow all commands specify '.*'", default=[])
  parser.add_argument('-c', '--cwd', metavar='', type=str, help="Set working directory", default=None)
  parser.add_argument('--authorized-key-file', action='append', metavar='', type=str, help="File path of authorized public key, multiple can be specified", default=[])
  parser.add_argument('--disable-auth', action='store_true', help="Disable authentication")
  FLAGS = parser.parse_args()
  if not FLAGS.disable_auth and len(FLAGS.authorized_key_file) == 0:
    raise ValueError('--authorized-key-file is a required arg if --disable-auth is not specified.')
  init_authorized_keys()
  if FLAGS.cwd:
    os.chdir(FLAGS.cwd)
  with serve(handler=websocket_handler, process_request=process_http_request, host="localhost", port=FLAGS.port) as server:
    print(f'Listening at {FLAGS.port}')
    server.serve_forever()
