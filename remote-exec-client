#!/usr/bin/env python3

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.asymmetric.types import PUBLIC_KEY_TYPES, PRIVATE_KEY_TYPES
from datetime import datetime, timezone

import argparse
import base64
import http.client
import sys

FLAGS = None

DEFAULT_PORT = 5567

def get_auth_token(pk_file) -> str:
  private_key: PRIVATE_KEY_TYPES = None
  content = None
  with open(pk_file, 'rb') as f:
    content = f.read()
  loaders = [
      serialization.load_pem_private_key,
      serialization.load_der_private_key,
      serialization.load_ssh_private_key
    ]
  for loader in loaders:
    try:
      private_key = loader(
        data = content,
        backend=default_backend(),
        password=None
      )
      break
    except Exception:
      pass
  now_timestamp = datetime.now(tz=timezone.utc).timestamp()
  data_bytes = str(now_timestamp).encode()
  sig = private_key.sign(data_bytes, ec.ECDSA(hashes.SHA256()))
  return '.'.join((base64.b64encode(data_bytes).decode(), base64.b64encode(sig).decode()))

def exec(cmd_args: list[str]) -> int:
  returncode = 1
  headers = {}
  auth_token = get_auth_token(FLAGS.private_key)
  headers['Authorization'] = auth_token
  if FLAGS.cwd:
    headers['CWD'] = FLAGS.cwd
  encoded_cmd = []
  for arg in cmd_args:
    encoded_cmd.append(bytes.hex(arg.encode()))
  try:
    conn = http.client.HTTPConnection('localhost', FLAGS.port)
    conn.request('POST', '/', headers=headers, body=':'.join(encoded_cmd))
    res = conn.getresponse()
    if res.status != http.client.OK:
      sys.stderr.write(res.reason)
      return
    for line in res:
      line = line.decode()
      if line.startswith('STDOUT:'):
        sys.stdout.write(bytes.fromhex(line[7:]).decode())
      elif line.startswith('STDERR:'):
        sys.stderr.write(bytes.fromhex(line[7:]).decode())
      elif line.startswith('CODE:'):
        returncode = int(bytes.fromhex(line[5:]).decode())
  finally:
    conn.close()
  return returncode
  

if __name__ == "__main__":
  all_args = sys.argv[1:]
  parser = argparse.ArgumentParser(description="Remote exec client sends command to remote server.")
  parser.add_argument('-c', '--cwd', metavar='', type=str, help="Sets working directory on remote server to run command", default=None)
  parser.add_argument('-p', '--port', metavar='', type=int, help="Remote exec server port", default=DEFAULT_PORT)
  parser.add_argument('--private-key', metavar='', type=str, help="Private key file, used for token signing", default=DEFAULT_PORT)
  internal_args = []
  cmd_args = []

  if '--' not in all_args:
    parser.parse_args() # Just to print help
    raise ValueError('Usage error, use -h/--help to know more')
  split_idx = all_args.index('--')
  internal_args = all_args[:split_idx]
  cmd_args = all_args[split_idx+1:]
  FLAGS = parser.parse_args(internal_args)
  sys.exit(exec(cmd_args))
