#!/usr/bin/env python3

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import dsa, ec, rsa, ed25519, ed448, padding
from cryptography.hazmat.primitives.asymmetric.types import PrivateKeyTypes
from datetime import datetime, timezone
from http import HTTPStatus
from websockets.sync.client import connect

import argparse
import base64
import logging
import sys
import threading
import traceback
import websockets

FLAGS = None

DEFAULT_PORT = 5567

SUPPORTED_KEY_TYPES = [
  dsa.DSAPrivateKey,
  rsa.RSAPrivateKey,
  ec.EllipticCurvePrivateKey,
  ed25519.Ed25519PrivateKey,
  ed448.Ed448PrivateKey,
]

class OutputType:
  STDOUT = 1
  STDERR = 2
  CODE   = 3

def exec(cmd_args: list[str]) -> int:
  encoded_cmd = []
  for arg in cmd_args:
    encoded_cmd.append(bytes.hex(arg.encode()))

  headers = {}
  if FLAGS.private_key:
    auth_token = get_auth_token(FLAGS.private_key)
    headers['Authorization'] = auth_token
  if FLAGS.cwd:
    headers['CWD'] = FLAGS.cwd
  with connect(f'ws://localhost:{FLAGS.port}', additional_headers=headers) as ws:
    ws.send(':'.join(encoded_cmd).encode())
    stream_stdin(ws)
    output_reader(ws)

def stream_stdin(ws: websockets.ClientConnection):
  def wrap():
    try:
      if not sys.stdin.isatty():
        while True:
          data = sys.stdin.readline(8192).encode()
          if not data:
            break
          ws.send(f'{len(data):x}\r\n'.encode() + data)
      ws.send(b'0\r\n')
    except websockets.ConnectionClosed:
      pass
  threading.Thread(target=wrap, daemon=True).start()

def output_reader(ws: websockets.ClientConnection):
  while True:
    line = None
    try:
      line = ws.recv()
    except websockets.exceptions.ConnectionClosed:
      return
    write_output(line)

def write_output(data: bytes):
  data = data.decode()
  global exit_code
  if data.startswith(f'{OutputType.STDOUT}:'):
    sys.stdout.write(bytes.fromhex(data[2:]).decode())
  elif data.startswith(f'{OutputType.STDERR}:'):
    sys.stderr.write(bytes.fromhex(data[2:]).decode())
  elif data.startswith(f'{OutputType.CODE}:'):
    exit_code = int(bytes.fromhex(data[2:]).decode())


def get_auth_token(pk_file) -> str:
  private_key: PrivateKeyTypes = None
  content = None
  with open(pk_file, 'rb') as f:
    content = f.read()
  loaders = [
      serialization.load_pem_private_key,
      serialization.load_der_private_key,
      serialization.load_ssh_private_key,
    ]
  for loader in loaders:
    try:
      private_key = loader(
        data = content,
        backend=default_backend(),
        password=None
      )
      break
    except Exception:
      pass
  now_timestamp = datetime.now(tz=timezone.utc).timestamp()
  data_bytes = str(now_timestamp).encode()
  sig = None
  if isinstance(private_key, ec.EllipticCurvePrivateKey):
    sig = private_key.sign(data=data_bytes, signature_algorithm=ec.ECDSA(hashes.SHA256()))
  elif isinstance(private_key, rsa.RSAPrivateKey):
    p = padding.PSS(
      mgf=padding.MGF1(hashes.SHA256()),
      salt_length=padding.PSS.MAX_LENGTH
    )
    sig = private_key.sign(data=data_bytes, padding=p, algorithm=hashes.SHA256())
  else:
    sig = private_key.sign(data=data_bytes, algorithm=hashes.SHA256())
  return '.'.join((base64.b64encode(data_bytes).decode(), base64.b64encode(sig).decode()))

exit_code = 1
if __name__ == "__main__":
  all_args = sys.argv[1:]
  parser = argparse.ArgumentParser(description="Remote exec client sends command to remote server.")
  parser.add_argument('-c', '--cwd', metavar='', type=str, help="Sets working directory on remote server to run command", default=None)
  parser.add_argument('-p', '--port', metavar='', type=int, help="Remote exec server port", default=DEFAULT_PORT)
  parser.add_argument('--private-key', metavar='', type=str, help="Private key file, used for auth token signing", default=None)
  parser.add_argument('--debug', action='store_true', help="Enable debug logging")
  internal_args = []
  cmd_args = []

  if '--' not in all_args:
    parser.parse_args() # Just to print help
    raise ValueError('Usage error, use -h/--help to know more')
  split_idx = all_args.index('--')
  internal_args = all_args[:split_idx]
  cmd_args = all_args[split_idx+1:]
  FLAGS = parser.parse_args(internal_args)
  if FLAGS.debug:
    logging.basicConfig(
        format="%(asctime)s %(message)s",
        level=logging.DEBUG,
    )
  try:
    exec(cmd_args)
  except KeyboardInterrupt:
    pass
  except websockets.exceptions.InvalidStatus as e:
    if e.response.status_code not in [HTTPStatus.UNAUTHORIZED, HTTPStatus.FORBIDDEN]:
      raise e
    write_output(e.response.body)
  except ConnectionRefusedError:
    sys.stderr.write(f'Connection refused at port {FLAGS.port}.\n')
  except Exception as e:
    traceback.print_exception(e)
  sys.exit(exit_code)
