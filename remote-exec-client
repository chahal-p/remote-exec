#!/usr/bin/env python3

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import dsa, ec, rsa, ed25519, ed448, padding
from cryptography.hazmat.primitives.asymmetric.types import PrivateKeyTypes
from datetime import datetime, timezone

import argparse
import base64
import http.client
import sys

FLAGS = None

DEFAULT_PORT = 5567

SUPPORTED_KEY_TYPES = [
  dsa.DSAPrivateKey,
  rsa.RSAPrivateKey,
  ec.EllipticCurvePrivateKey,
  ed25519.Ed25519PrivateKey,
  ed448.Ed448PrivateKey,
]

def exec(cmd_args: list[str]) -> int:
  returncode = 1
  headers = {}
  if FLAGS.private_key:
    auth_token = get_auth_token(FLAGS.private_key)
    headers['Authorization'] = auth_token
  if FLAGS.cwd:
    headers['CWD'] = FLAGS.cwd
  encoded_cmd = []
  for arg in cmd_args:
    encoded_cmd.append(bytes.hex(arg.encode()))
  try:
    conn = http.client.HTTPConnection('localhost', FLAGS.port)
    headers['Transfer-Encoding'] = 'chunked'
    headers['Content-Type'] = 'application/octet-stream'
    conn.request('POST', '/', headers=headers, encode_chunked=True)
    stream_body(conn, ':'.join(encoded_cmd))
    res = conn.getresponse()
    if res.status != http.client.OK:
      sys.stderr.write(res.reason)
      return
    for line in res:
      line = line.decode()
      if line.startswith('STDOUT:'):
        sys.stdout.write(bytes.fromhex(line[7:]).decode())
      elif line.startswith('STDERR:'):
        sys.stderr.write(bytes.fromhex(line[7:]).decode())
      elif line.startswith('CODE:'):
        returncode = int(bytes.fromhex(line[5:]).decode())
  except ConnectionResetError:
    print(f"Connection reset by peer at port {FLAGS.port}")
    returncode = 1
  except ConnectionRefusedError:
    print(f"Connection refused at port {FLAGS.port}")
    returncode = 1
  except KeyboardInterrupt:
    returncode = 1
  finally:
    conn.close()
  return returncode

def get_auth_token(pk_file) -> str:
  private_key: PrivateKeyTypes = None
  content = None
  with open(pk_file, 'rb') as f:
    content = f.read()
  loaders = [
      serialization.load_pem_private_key,
      serialization.load_der_private_key,
      serialization.load_ssh_private_key,
    ]
  for loader in loaders:
    try:
      private_key = loader(
        data = content,
        backend=default_backend(),
        password=None
      )
      break
    except Exception:
      pass
  now_timestamp = datetime.now(tz=timezone.utc).timestamp()
  data_bytes = str(now_timestamp).encode()
  sig = None
  if isinstance(private_key, ec.EllipticCurvePrivateKey):
    sig = private_key.sign(data=data_bytes, signature_algorithm=ec.ECDSA(hashes.SHA256()))
  elif isinstance(private_key, rsa.RSAPrivateKey):
    p = padding.PSS(
      mgf=padding.MGF1(hashes.SHA256()),
      salt_length=padding.PSS.MAX_LENGTH
    )
    sig = private_key.sign(data=data_bytes, padding=p, algorithm=hashes.SHA256())
  else:
    sig = private_key.sign(data=data_bytes, algorithm=hashes.SHA256())
  return '.'.join((base64.b64encode(data_bytes).decode(), base64.b64encode(sig).decode()))

def encode_http_chunk(data: bytes):
  return f'{len(data):x}\r\n'.encode() + data + b'\r\n'

def stream_body(conn: http.client.HTTPConnection, cmd: str):
  def input_reader():
    yield encode_http_chunk(cmd.encode())
    if not sys.stdin.isatty():
      for line in sys.stdin:
        yield encode_http_chunk(line.encode())
    yield b'0\r\n\r\n'
  for chunk in input_reader():
    conn.send(chunk)

if __name__ == "__main__":
  all_args = sys.argv[1:]
  parser = argparse.ArgumentParser(description="Remote exec client sends command to remote server.")
  parser.add_argument('-c', '--cwd', metavar='', type=str, help="Sets working directory on remote server to run command", default=None)
  parser.add_argument('-p', '--port', metavar='', type=int, help="Remote exec server port", default=DEFAULT_PORT)
  parser.add_argument('--private-key', metavar='', type=str, help="Private key file, used for auth token signing", default=None)
  parser.add_argument('--debug', action='store_true', help="Enable debug logging")
  internal_args = []
  cmd_args = []

  if '--' not in all_args:
    parser.parse_args() # Just to print help
    raise ValueError('Usage error, use -h/--help to know more')
  split_idx = all_args.index('--')
  internal_args = all_args[:split_idx]
  cmd_args = all_args[split_idx+1:]
  FLAGS = parser.parse_args(internal_args)
  if FLAGS.debug:
    http.client.HTTPConnection.debuglevel = 1
  sys.exit(exec(cmd_args))
