#!/usr/bin/env python3

import json
import socket
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import dsa, ec, rsa, ed25519, ed448, padding
from cryptography.hazmat.primitives.asymmetric.types import PrivateKeyTypes
from datetime import datetime, timezone

import argparse
import base64
import logging
import os
import sys
import threading
import traceback

FLAGS = None

DEFAULT_PORT = 5567

AUTH_TOKEN_EXPIRY = 3 #seconds

MAX_MESSAGE_SIZE = 1024 * 512

SUPPORTED_KEY_TYPES = [
  dsa.DSAPrivateKey,
  rsa.RSAPrivateKey,
  ec.EllipticCurvePrivateKey,
  ed25519.Ed25519PrivateKey,
  ed448.Ed448PrivateKey,
]

class OutputType:
  PING   = 0
  STDOUT = 1
  STDERR = 2
  CODE   = 3

############################################################
class TCPConnection():
  LENGTH_PREFIX = 4
  MAX_DATA_SIZE = 0xffffff

  TYPE_PING     = 0
  TYPE_PONG     = 1
  TYPE_DATA     = 2

  _sock: socket.socket
  def __init__(self, sock: socket.socket):
    self._sock = sock

  def _recv(self, size):
    data = self._sock.recv(size)
    if data:
      return data
    raise ConnectionClosed()

  def recv(self):
    len = int.from_bytes(self._recv(self.LENGTH_PREFIX))
    if len == 0:
      return b''
    return self._sock.recv(len) 
  
  def send(self, data: bytes):
    le = len(data)
    if le > self.MAX_DATA_SIZE:
      raise ValueError('Max allowed data size %d' % self.MAX_DATA_SIZE)
    try:
      self._sock.sendall(int.to_bytes(le, length=self.LENGTH_PREFIX) + data)
    except (BrokenPipeError, ConnectionResetError, TimeoutError) as e:
      raise ConnectionClosed(e)

  def remote_address(self):
    return self._sock.getpeername()

  def close(self):
    self._sock.close()

class ConnectionClosed(Exception): pass
############################################################

def exec(cmd_args: list[str]) -> int:
  encoded_cmd = []
  for arg in cmd_args:
    encoded_cmd.append(base64.b64encode(arg.encode()).decode())

  request = {}
  if FLAGS.private_key:
    auth_token = get_auth_token(FLAGS.private_key)
    request['Authorization'] = auth_token
  if FLAGS.cwd:
    request['CWD'] = FLAGS.cwd
  request['CMD'] = ':'.join(encoded_cmd)
  request_bytes = json.dumps(request).encode()
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
    sock.connect(('127.0.0.1', FLAGS.port))
    conn = TCPConnection(sock)
    conn.send(request_bytes)
    stream_stdin(conn)
    output_reader(conn)

def stream_stdin(conn: TCPConnection):
  def wrap():
    try:
      if not sys.stdin.isatty():
        while True:
          data = os.read(sys.stdin.fileno(), MAX_MESSAGE_SIZE)
          if not data:
            break
          conn.send(data)
      conn.send(b'')
    except ConnectionClosed:
      pass
  threading.Thread(target=wrap, daemon=True).start()

def output_reader(conn: TCPConnection):
  while True:
    data = None
    try:
      data = conn.recv()
    except ConnectionClosed:
      return
    write_output(data)

def write_output(data: bytes):
  type, data = data[0], data[1:]
  global exit_code
  if type == OutputType.PING:
    return
  if type == OutputType.STDOUT:
    sys.stdout.buffer.write(data)
    sys.stdout.flush()
  elif type == OutputType.STDERR:
    sys.stderr.buffer.write(data)
    sys.stderr.flush()
  elif type == OutputType.CODE:
    exit_code = int.from_bytes(data)
  else:
    raise TypeError('Unknown output type')

def get_auth_token(pk_file) -> str:
  private_key: PrivateKeyTypes = None
  content = None
  with open(pk_file, 'rb') as f:
    content = f.read()
  loaders = [
      serialization.load_pem_private_key,
      serialization.load_der_private_key,
      serialization.load_ssh_private_key,
    ]
  for loader in loaders:
    try:
      private_key = loader(
        data = content,
        backend=default_backend(),
        password=None
      )
      break
    except Exception:
      pass
  expiry_timestamp = datetime.now(tz=timezone.utc).timestamp() + AUTH_TOKEN_EXPIRY
  data_bytes = str(expiry_timestamp).encode()
  sig = None
  if isinstance(private_key, ec.EllipticCurvePrivateKey):
    sig = private_key.sign(data=data_bytes, signature_algorithm=ec.ECDSA(hashes.SHA256()))
  elif isinstance(private_key, rsa.RSAPrivateKey):
    p = padding.PSS(
      mgf=padding.MGF1(hashes.SHA256()),
      salt_length=padding.PSS.MAX_LENGTH
    )
    sig = private_key.sign(data=data_bytes, padding=p, algorithm=hashes.SHA256())
  else:
    sig = private_key.sign(data=data_bytes, algorithm=hashes.SHA256())
  return '.'.join((base64.b64encode(data_bytes).decode(), base64.b64encode(sig).decode()))

class CustomUsageFormatter(argparse.HelpFormatter):
  def _format_usage(self, usage, actions, groups, prefix):
    return super()._format_usage(usage, actions, groups, prefix).rstrip('\n') + ' -- <command to be executed on remote>\n\n'

exit_code = 1
if __name__ == "__main__":
  all_args = sys.argv[1:]
  parser = argparse.ArgumentParser(description="Remote exec client sends command to remote server.", formatter_class=CustomUsageFormatter)
  parser.add_argument('-c', '--cwd', metavar='', type=str, help="Sets working directory on remote server to run command", default=None)
  parser.add_argument('-p', '--port', metavar='', type=int, help="Remote exec server port", default=DEFAULT_PORT)
  parser.add_argument('--private-key', metavar='', type=str, help="Private key file, used for auth token signing", default=None)
  parser.add_argument('--debug', action='store_true', help="Enable debug logging")
  internal_args = []
  cmd_args = []

  if '--' not in all_args:
    parser.parse_args() # Just to print help
    raise ValueError('Usage error, use -h/--help to know more')
  split_idx = all_args.index('--')
  internal_args = all_args[:split_idx]
  cmd_args = all_args[split_idx+1:]
  FLAGS = parser.parse_args(internal_args)
  if FLAGS.debug:
    logging.basicConfig(
        format="%(asctime)s %(message)s",
        level=logging.DEBUG,
    )
  try:
    exec(cmd_args)
  except KeyboardInterrupt:
    pass
  except ConnectionRefusedError:
    sys.stderr.write(f'Connection refused at port {FLAGS.port}.\n')
  except Exception as e:
    traceback.print_exception(e)
  sys.exit(exit_code)
